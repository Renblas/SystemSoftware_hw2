/* $Id: spl_lexer_definitions_top.l,v 1.4 2024/10/06 19:16:25 leavens Exp leavens $ */
/* Lexical Analyzer for SPL */

%option header-file = "spl_lexer.h"
%option outfile = "spl_lexer.c"
%option yylineno
%option bison-bridge

%{
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <assert.h>
#include <limits.h>
#include "ast.h"
#include "parser_types.h"
#include "utilities.h"
#include "lexer.h"

 /* Tokens generated by Bison */
#include "spl.tab.h"

 /* need declaration of fileno, part of the C standard library.
   (Putting an extern declaration here shuts off a gcc warning.) */
extern int fileno(FILE *stream);

/* The filename of the file being read */
static char *input_filename;

/* Have any errors been noted? */
static bool errors_noted;

/* The value of a token */
extern YYSTYPE yylval;

/* The FILE used by the generated lexer */
extern FILE *yyin;

// We are not using yyunput or input
#define YY_NO_UNPUT
#define YY_NO_INPUT

#undef yywrap   /* sometimes a macro by default */

// apparently strdup is not declared in <string.h>
extern char *strdup(const char *s);

// set the lexer's value for a token in yylval as an AST
static void tok2ast(int code) {
    AST t;
    t.token.file_loc = file_location_make(input_filename, yylineno);
    t.token.type_tag = token_ast;
    t.token.code = code;
    t.token.text = strdup(yytext);
    yylval = t;
}

static void ident2ast(const char *name) {
    AST t;
    assert(input_filename != NULL);
    t.ident.file_loc = file_location_make(input_filename, yylineno);
    t.ident.type_tag = ident_ast;
    t.ident.name = strdup(name);
    yylval = t;
}

static void number2ast(unsigned int val)
{
    AST t;
    t.number.file_loc = file_location_make(input_filename, yylineno);
    t.number.type_tag = number_ast;
    t.number.text = strdup(yytext);
    t.number.value = val;
    yylval = t;
}

%}

	/* DEFINITIONS */

	/* his stuff for assembly 
	DECDIGIT	[0-9]
	UNSIGNEDNUMBER  (((0x)[0-9A-Fa-f]+)|{DECDIGIT}+)
	LETTER		[_a-zA-Z]
	LETTERORDIGIT	({LETTER}|{DECDIGIT})
	IDENT		{LETTER}({LETTERORDIGIT}*)
	NEWLINE         \n
	CR              \r
	EOL             ({NEWLINE}|({CR}{NEWLINE}))
	COMMENTSTART    %
	COMMENT         {COMMENTSTART}.*
	IGNORED         [ \t\v\f\r] */


	/* my stuff for SPL */
	IDENT				({LETTER} {LETTER_OR_DIGIT})
	LETTER				[a-zA-Z]
	NUMBER				(DIGIT {DIGIT})
	DIGIT				[0-9]
	LETTER_OR_DIGIT		({LETTER} | {DIGIT})
	PLUS				[+]
	MINUS				[-]
	

	/* His description of SPL Rules 
	⟨ident⟩ ::= ⟨letter⟩ {⟨letter-or-digit⟩}
	⟨letter⟩ ::= a | b | . . . | y | z | A | B | . . . | Y | Z
	⟨number⟩ ::= ⟨digit⟩ {⟨digit⟩}
	⟨digit⟩ ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
	⟨letter-or-digit⟩ ::= ⟨letter⟩ | ⟨digit⟩
	⟨plus⟩ ::= +
	⟨minus⟩ ::= -
	⟨mult⟩ ::= *
	⟨div⟩ ::= /
	⟨punctuation⟩ ::= . | ; | = | , | := | ( | )
	⟨reserved-word⟩ ::= const | var | proc | call | begin | end | if | then | else | while | do | read | print | divisible | by
	⟨rel-ops⟩ ::= == | != | < | <= | > | >=
	⟨ignored⟩ ::= ⟨blank⟩ | ⟨tab⟩ | ⟨vt⟩ | ⟨formfeed⟩ | ⟨eol⟩ | ⟨comment⟩
	⟨blank⟩ ::= “A space character (ASCII 32)”
	⟨tab⟩ ::= “A horizontal tab character (ASCII 9)”
	⟨vt⟩ ::= “A vertical tab character (ASCII 11)”
	⟨formfeed⟩ ::= “A formfeed character (ASCII 12)”
	⟨newline⟩ ::= “A newline character (ASCII 10)”
	⟨cr⟩ ::= “A carriage return character (ASCII 13)”
	⟨eol⟩ ::= ⟨newline⟩ | ⟨cr⟩ ⟨newline⟩
	⟨comment⟩ ::= ⟨percent-sign⟩ {⟨non-nl⟩} ⟨newline⟩
	⟨percent-sign⟩ ::= %
	⟨non-nl⟩ ::= “Any character except a newline” */


 

%%

/* RULES */

{IGNORED}       { ; } /* do nothing */
{COMMENT}       { ; } /* ignore comments */
<INSTRUCTION>{EOL} { BEGIN INITIAL; return eolsym; }
<DATADECL>{EOL} { BEGIN INITIAL; return eolsym; }
{EOL}           { ; } /* ignore EOL outside of the above states */

ADD             { BEGIN INSTRUCTION; tok2ast(addopsym); return addopsym; }
SUB             { BEGIN INSTRUCTION; tok2ast(subopsym); return subopsym; }
AND             { BEGIN INSTRUCTION; tok2ast(andopsym); return andopsym; }
BOR             { BEGIN INSTRUCTION; tok2ast(boropsym); return boropsym; }
NOR             { BEGIN INSTRUCTION; tok2ast(noropsym); return noropsym; }
XOR             { BEGIN INSTRUCTION; tok2ast(xoropsym); return xoropsym; }
MUL             { BEGIN INSTRUCTION; tok2ast(mulopsym); return mulopsym; }
DIV             { BEGIN INSTRUCTION; tok2ast(divopsym); return divopsym; }
SLL             { BEGIN INSTRUCTION; tok2ast(sllopsym); return sllopsym; }
SRL             { BEGIN INSTRUCTION; tok2ast(srlopsym); return srlopsym; }
MFHI            { BEGIN INSTRUCTION; tok2ast(mfhiopsym); return mfhiopsym; }
MFLO            { BEGIN INSTRUCTION; tok2ast(mfloopsym); return mfloopsym; }
JR              { BEGIN INSTRUCTION; tok2ast(jropsym); return jropsym; }
ADDI            { BEGIN INSTRUCTION; tok2ast(addiopsym); return addiopsym; }
ANDI            { BEGIN INSTRUCTION; tok2ast(andiopsym); return andiopsym; }
BORI            { BEGIN INSTRUCTION; tok2ast(boriopsym); return boriopsym; }
XORI            { BEGIN INSTRUCTION; tok2ast(xoriopsym); return xoriopsym; }
BEQ             { BEGIN INSTRUCTION; tok2ast(beqopsym); return beqopsym; }
BGEZ            { BEGIN INSTRUCTION; tok2ast(bgezopsym); return bgezopsym; }
BLEZ            { BEGIN INSTRUCTION; tok2ast(blezopsym); return blezopsym; }
BGTZ            { BEGIN INSTRUCTION; tok2ast(bgtzopsym); return bgtzopsym; }
BLTZ            { BEGIN INSTRUCTION; tok2ast(bltzopsym); return bltzopsym; }
BNE             { BEGIN INSTRUCTION; tok2ast(bneopsym); return bneopsym; }
LBU             { BEGIN INSTRUCTION; tok2ast(lbuopsym); return lbuopsym; }



PROGRAM         {BLOCK}
BLOCK           {}
CONST-DECLS     {}
CONST-DECL      {}
CONST-DEF-LIST  {}
CONST-DEF       {}
VAR-DECLS       {}

/*
⟨program⟩ ::= ⟨block⟩ .
⟨block⟩ ::= begin ⟨const-decls⟩ ⟨var-decls⟩ ⟨proc-decls⟩ ⟨stmts⟩ end
⟨const-decls⟩ ::= {⟨const-decl⟩}
⟨const-decl⟩ ::= const ⟨const-def-list⟩ ;
⟨const-def-list⟩ ::= ⟨const-def⟩ | ⟨const-defs⟩ , ⟨const-def⟩
⟨const-def⟩ ::= ⟨ident⟩ = ⟨number⟩
⟨var-decls⟩ ::= {⟨var-decl⟩}
⟨var-decl⟩ ::= var ⟨ident-list⟩ ;
⟨ident-list⟩ ::= ⟨ident⟩ | ⟨idents⟩ , ⟨ident⟩
⟨proc-decls⟩ ::= {⟨proc-decl⟩}
⟨proc-decl⟩ ::= proc ⟨ident⟩ ⟨block⟩ ;
⟨stmts⟩ ::= ⟨empty⟩ | ⟨stmt-list⟩
⟨empty⟩ ::=
⟨stmt-list⟩ ::= ⟨stmt⟩ | ⟨stmt-list⟩ ; ⟨stmt⟩
⟨stmt⟩ ::= ⟨assign-stmt⟩ | ⟨call-stmt⟩ | ⟨if-stmt⟩ | ⟨while-stmt⟩ | ⟨read-stmt⟩ | ⟨print-stmt⟩ | ⟨block-stmt⟩
⟨assign-stmt⟩ ::= ⟨ident⟩ := ⟨expr⟩
⟨call-stmt⟩ ::= call ⟨ident⟩
⟨if-stmt⟩ ::= if ⟨condition⟩ then ⟨stmts⟩ else ⟨stmts⟩ end | if ⟨condition⟩ then ⟨stmts⟩ end
⟨while-stmt⟩ ::= while ⟨condition⟩ do ⟨stmts⟩ end
⟨read-stmt⟩ ::= read ⟨ident⟩
⟨print-stmt⟩ ::= print ⟨expr⟩
⟨block-stmt⟩ ::= ⟨block⟩
⟨condition⟩ ::= ⟨db-condition⟩ | ⟨rel-op-condition⟩
⟨db-condition⟩ ::= divisible ⟨expr⟩ by ⟨expr⟩
⟨rel-op-condition⟩ ::= ⟨expr⟩ ⟨rel-op⟩ ⟨expr⟩
⟨rel-op⟩ ::= == | != | < | <= | > | >=
⟨expr⟩ ::= ⟨term⟩ | ⟨expr⟩ ⟨plus⟩ ⟨term⟩ | ⟨expr⟩ ⟨minus⟩ ⟨term⟩
⟨term⟩ ::= ⟨factor⟩ | ⟨term⟩ ⟨mult⟩ ⟨factor⟩ | ⟨term⟩ ⟨div⟩ ⟨factor⟩
⟨factor⟩ ::= ⟨ident⟩ | ⟨number⟩ | ⟨sign⟩ ⟨factor⟩ | ( ⟨expr⟩ )
⟨sign⟩ ::= ⟨minus⟩ | ⟨plus⟩ */

 /* fill in the rules for your lexer below! */

%%/* $Id: spl_lexer_user_code.c,v 1.4 2024/10/06 18:43:01 leavens Exp leavens $ */

/* This code goes in the user code section of the spl_lexer.l file,
  following the last %% above. */

  // Requires: fname != NULL
  // Requires: fname is the name of a readable file
  // Initialize the lexer and start it reading
  // from the given file name
void lexer_init(char* fname)
{
	errors_noted = false;
	yyin = fopen(fname, "r");
	if (yyin == NULL) {
		bail_with_error("Cannot open %s", fname);
	}
	input_filename = fname;
}

// Close the file yyin
// and return 0 to indicate that there are no more files
int yywrap() {
	if (yyin != NULL) {
		int rc = fclose(yyin);
		if (rc == EOF) {
			bail_with_error("Cannot close %s!", input_filename);
		}
	}
	input_filename = NULL;
	return 1;  /* no more input */
}

// Return the name of the current input file
const char* lexer_filename() {
	return input_filename;
}

// Return the line number of the next token
unsigned int lexer_line() {
	return yylineno;
}

/* Report an error to the user on stderr */
void yyerror(const char* filename, const char* msg)
{
	fflush(stdout);
	fprintf(stderr, "%s:%d: %s\n", input_filename, lexer_line(), msg);
	errors_noted = true;
}

// On standard output:
// Print a message about the file name of the lexer's input
// and then print a heading for the lexer's output.
void lexer_print_output_header()
{
	printf("Tokens from file %s\n", lexer_filename());
	printf("%-6s %-4s  %s\n", "Number", "Line", "Text");
}

// Have any errors been noted by the lexer?
bool lexer_has_errors()
{
	return errors_noted;
}

// Print information about the token t to stdout
// followed by a newline
void lexer_print_token(enum yytokentype t, unsigned int tline,
			   const char* txt)
{
	printf("%-6d %-4d \"%s\"\n", t, tline, txt);
}


/* Read all the tokens from the input file
 * and print each token on standard output
 * using the format in lexer_print_token */
void lexer_output()
{
	lexer_print_output_header();
	AST dummy;
	yytoken_kind_t t;
	do {
		t = yylex(&dummy);
		if (t == YYEOF) {
			break;
		}
		lexer_print_token(t, yylineno, yytext);
	} while (t != YYEOF);
}
