/* $Id: spl_lexer_definitions_top.l,v 1.4 2024/10/06 19:16:25 leavens Exp leavens $ */
/* Lexical Analyzer for SPL */

%option header-file = "spl_lexer.h"
%option outfile = "spl_lexer.c"
%option yylineno
%option bison-bridge

%{
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <assert.h>
#include <limits.h>
#include "ast.h"
#include "parser_types.h"
#include "utilities.h"
#include "lexer.h"

 /* Tokens generated by Bison */
#include "spl.tab.h"

 /* need declaration of fileno, part of the C standard library.
   (Putting an extern declaration here shuts off a gcc warning.) */
extern int fileno(FILE *stream);

/* The filename of the file being read */
static char *input_filename;

/* Have any errors been noted? */
static bool errors_noted;

/* The value of a token */
extern YYSTYPE yylval;

/* The FILE used by the generated lexer */
extern FILE *yyin;

// We are not using yyunput or input
#define YY_NO_UNPUT
#define YY_NO_INPUT

#undef yywrap   /* sometimes a macro by default */

// apparently strdup is not declared in <string.h>
extern char *strdup(const char *s);

// set the lexer's value for a token in yylval as an AST
static void tok2ast(int code) {
    AST t;
    t.token.file_loc = file_location_make(input_filename, yylineno);
    t.token.type_tag = token_ast;
    t.token.code = code;
    t.token.text = strdup(yytext);
    yylval = t;
}

static void ident2ast(const char *name) {
    AST t;
    assert(input_filename != NULL);
    t.ident.file_loc = file_location_make(input_filename, yylineno);
    t.ident.type_tag = ident_ast;
    t.ident.name = strdup(name);
    yylval = t;
}

static void number2ast(unsigned int val)
{
    AST t;
    t.number.file_loc = file_location_make(input_filename, yylineno);
    t.number.type_tag = number_ast;
    t.number.text = strdup(yytext);
    t.number.value = val;
    yylval = t;
}

%}

	/* DEFINITIONS */
	
	ident				({letter} {letter_or_digit})
	letter				[a-zA-Z]
	number				(digit {digit})
	digit				[0-9]
	letter_or_digit		({letter} | {letter})
	plus				[+]
	minus				[-]
	mult				[*]
	div					[/]
	punctuation			[.;=,] | (:=) | ( | )
	reserved-word		const | var | proc | call | begin | end | if | then | else | while | do | read | print | divisible | by
	rel-ops				== | != | < | <= | > | >=
	ignored				{blank} | {tab} | {vt} | {formfeed} | {eol} | {comment}
	blank				\32
	tab					\9
	vt					\11
	formfeed			\12
	newline				\10
	cr					\13
	eol					{newline} | {cr} {newline}
	comment				{percent-siggn} {non-nl}+ {newline}
	percent-sign		%
	non-nl				[^\n]

%%

/* RULES */

{IGNORED}       { ; } /* do nothing */
{COMMENT}       { ; } /* ignore comments */
<INSTRUCTION>{EOL} { BEGIN INITIAL; return eolsym; }
<DATADECL>{EOL} { BEGIN INITIAL; return eolsym; }
{EOL}           { ; } /* ignore EOL outside of the above states */

ADD             { BEGIN INSTRUCTION; tok2ast(addopsym); return addopsym; }
SUB             { BEGIN INSTRUCTION; tok2ast(subopsym); return subopsym; }
AND             { BEGIN INSTRUCTION; tok2ast(andopsym); return andopsym; }
BOR             { BEGIN INSTRUCTION; tok2ast(boropsym); return boropsym; }
NOR             { BEGIN INSTRUCTION; tok2ast(noropsym); return noropsym; }
XOR             { BEGIN INSTRUCTION; tok2ast(xoropsym); return xoropsym; }
MUL             { BEGIN INSTRUCTION; tok2ast(mulopsym); return mulopsym; }
DIV             { BEGIN INSTRUCTION; tok2ast(divopsym); return divopsym; }
SLL             { BEGIN INSTRUCTION; tok2ast(sllopsym); return sllopsym; }
SRL             { BEGIN INSTRUCTION; tok2ast(srlopsym); return srlopsym; }
MFHI            { BEGIN INSTRUCTION; tok2ast(mfhiopsym); return mfhiopsym; }
MFLO            { BEGIN INSTRUCTION; tok2ast(mfloopsym); return mfloopsym; }
JR              { BEGIN INSTRUCTION; tok2ast(jropsym); return jropsym; }
ADDI            { BEGIN INSTRUCTION; tok2ast(addiopsym); return addiopsym; }
ANDI            { BEGIN INSTRUCTION; tok2ast(andiopsym); return andiopsym; }
BORI            { BEGIN INSTRUCTION; tok2ast(boriopsym); return boriopsym; }
XORI            { BEGIN INSTRUCTION; tok2ast(xoriopsym); return xoriopsym; }
BEQ             { BEGIN INSTRUCTION; tok2ast(beqopsym); return beqopsym; }
BGEZ            { BEGIN INSTRUCTION; tok2ast(bgezopsym); return bgezopsym; }
BLEZ            { BEGIN INSTRUCTION; tok2ast(blezopsym); return blezopsym; }
BGTZ            { BEGIN INSTRUCTION; tok2ast(bgtzopsym); return bgtzopsym; }
BLTZ            { BEGIN INSTRUCTION; tok2ast(bltzopsym); return bltzopsym; }
BNE             { BEGIN INSTRUCTION; tok2ast(bneopsym); return bneopsym; }
LBU             { BEGIN INSTRUCTION; tok2ast(lbuopsym); return lbuopsym; }



program				{block} .
block          		begin {const-decls} {var-decls} {proc-decls} {stmts} end
const-decls    		{const-decl}+
const-decl      	const {const-def-list} ;
const-def-list    	{const-def} | {const-defs} , {const-def}
const-def       	{ident} = {number}
var-decls       	{var-decl}+
var-decl            	var {ident-list}
ident-list		{ident} | {idents} , {ident}
proc-decls		{proc-decl}+
proc-decl		proc {ident} {block} ;
stmts			{empty} | {stmt-list}
empty			
stmt-list		{stmt} | {stmt-list} ; {stmt}
stmt			{assign-stmt} | {call-stmt} | {if-stmt} | {while-stmt} | {read-stmt} | {print-stmt} | {block-stmt}
assign-stmt		{ident} = {expr}
call-stmt		call {ident}
if-stmt			if {condition} then {stmts} else {stmts} end | if {condition} then {stmts} end
while-stmt		while {condition} do {stmts} end
read-stmt		read {ident}
print-stmt		print{expr}
block-stmt		{block}
condition		{db-condition} | {rel-op-condition}
db-condition		divisible {expr} by {expr}
rel-op-condition	{expr} {rel-op} {expr}
rel-op			== | != | < | <= | > | >=
expr			{term} | {expr} {plus} {term} | {expr} {minus} {term}
term			{factor} | {term} {mult} {factor} | {term} {div} {factor}
factor			{ident} | {number} | {sign} {factor} | ( {exper} )
sign			{minus} | {plus}


/*
⟨program⟩ ::= ⟨block⟩ .
⟨block⟩ ::= begin ⟨const-decls⟩ ⟨var-decls⟩ ⟨proc-decls⟩ ⟨stmts⟩ end
⟨const-decls⟩ ::= {⟨const-decl⟩}
⟨const-decl⟩ ::= const ⟨const-def-list⟩ ;
⟨const-def-list⟩ ::= ⟨const-def⟩ | ⟨const-defs⟩ , ⟨const-def⟩
⟨const-def⟩ ::= ⟨ident⟩ = ⟨number⟩
⟨var-decls⟩ ::= {⟨var-decl⟩}
⟨var-decl⟩ ::= var ⟨ident-list⟩ ;
⟨ident-list⟩ ::= ⟨ident⟩ | ⟨idents⟩ , ⟨ident⟩
⟨proc-decls⟩ ::= {⟨proc-decl⟩}
⟨proc-decl⟩ ::= proc ⟨ident⟩ ⟨block⟩ ;
⟨stmts⟩ ::= ⟨empty⟩ | ⟨stmt-list⟩
⟨empty⟩ ::=
⟨stmt-list⟩ ::= ⟨stmt⟩ | ⟨stmt-list⟩ ; ⟨stmt⟩
⟨stmt⟩ ::= ⟨assign-stmt⟩ | ⟨call-stmt⟩ | ⟨if-stmt⟩ | ⟨while-stmt⟩ | ⟨read-stmt⟩ | ⟨print-stmt⟩ | ⟨block-stmt⟩
⟨assign-stmt⟩ ::= ⟨ident⟩ := ⟨expr⟩
⟨call-stmt⟩ ::= call ⟨ident⟩
⟨if-stmt⟩ ::= if ⟨condition⟩ then ⟨stmts⟩ else ⟨stmts⟩ end | if ⟨condition⟩ then ⟨stmts⟩ end
⟨while-stmt⟩ ::= while ⟨condition⟩ do ⟨stmts⟩ end
⟨read-stmt⟩ ::= read ⟨ident⟩
⟨print-stmt⟩ ::= print ⟨expr⟩
⟨block-stmt⟩ ::= ⟨block⟩
⟨condition⟩ ::= ⟨db-condition⟩ | ⟨rel-op-condition⟩
⟨db-condition⟩ ::= divisible ⟨expr⟩ by ⟨expr⟩
⟨rel-op-condition⟩ ::= ⟨expr⟩ ⟨rel-op⟩ ⟨expr⟩
⟨rel-op⟩ ::= == | != | < | <= | > | >=
⟨expr⟩ ::= ⟨term⟩ | ⟨expr⟩ ⟨plus⟩ ⟨term⟩ | ⟨expr⟩ ⟨minus⟩ ⟨term⟩
⟨term⟩ ::= ⟨factor⟩ | ⟨term⟩ ⟨mult⟩ ⟨factor⟩ | ⟨term⟩ ⟨div⟩ ⟨factor⟩
⟨factor⟩ ::= ⟨ident⟩ | ⟨number⟩ | ⟨sign⟩ ⟨factor⟩ | ( ⟨expr⟩ )
⟨sign⟩ ::= ⟨minus⟩ | ⟨plus⟩ */

 /* fill in the rules for your lexer below! */

%%
